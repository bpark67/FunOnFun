[{"path":"https://bpark67.github.io/FunOnFun/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 FunOnFun authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"FunOnFun","text":"Welcome FunOnFun package! package designed conduct multivariate functional Principal Component Analysis (MFPCA) irregularly observed data. Let us generate data:","code":""},{"path":[]},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"independence","dir":"Articles","previous_headings":"Generate Data","what":"Independence","title":"FunOnFun","text":"","code":"set.seed(16)  n = 20 t = seq(0, 1, length.out = 50) components = 2  mean_funs = list(   function(t) -2*(t-0.5)^2 + 5,   function(t) 3*(t-0.75)^3 - 5   )  eigen_funs_list = list(   list(     function(t) sin(pi*t),     function(t) cos(pi*t)   ),   list(     function(t) sin(3*pi*t),     function(t) cos(3*pi*t)   ) )  lambdas = c(5, 3)  X = FunOnFun::simMFPCA(16, t, n, components, mean_funs, eigen_funs_list, lambdas, response = FALSE)"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"dependent","dir":"Articles","previous_headings":"Generate Data","what":"Dependent","title":"FunOnFun","text":"","code":"mean_funs = list(   function(t) 6*exp(-(t-1)^2),   function(t) -2*14^(t-0.5) )  eigen_funs_list = list(   list(     function(t) cos(5*pi*t),     function(t) sin(5*pi*t)   ),   list(     function(t) sin(3*pi*t),     function(t) cos(3*pi*t)   ) )  B = matrix(c(5, 6, 7, 8),            nrow = components,            ncol = components)  Y = FunOnFun::simMFPCA(16, t, n, components, mean_funs, eigen_funs_list, lambdas, response = TRUE, B = B) sigma = 0.001 E = matrix(rnorm(2*length(t)*n, mean = 0, sd = sigma), n, 2*length(t))  Y$X = Y$X + E"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"visualize","dir":"Articles","previous_headings":"Generate Data","what":"Visualize","title":"FunOnFun","text":"","code":"matplot(t(X$X),          type='l',          ylab='X(t)',          xlab='time',          main='Plot of predictor curves',          col=rgb(0,0,0,alpha=0.4)) matlines(apply(t(X$X), 1, mean),          type='l',          lwd=3,          lty=1,          col=\"red\") matplot(t(Y$X),          type='l',          ylab='Y(t)',          xlab='time',          main='Plot of response curves',          col=rgb(0,0,0,alpha=0.6)) matlines(apply(t(Y$X), 1, mean),          type='l',          lwd=3,          lty=1,          col = \"red\")"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"simulate-irregular-missingness","dir":"Articles","previous_headings":"Generate Data","what":"Simulate Irregular Missingness","title":"FunOnFun","text":"","code":"X_miss = FunOnFun::simMiss(40, X$X, t, seed = 51) Y_miss = FunOnFun::simMiss(40, Y$X, t, seed = 51)"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"visualize-missingness","dir":"Articles","previous_headings":"Generate Data","what":"Visualize Missingness","title":"FunOnFun","text":"","code":"matplot(t(X_miss),          type='l',          ylab='X(t)',          xlab='time',          main='Plot of predictor curves with missingness',          col=rgb(0,0,0,alpha=0.4)) matlines(apply(t(X_miss), 1, mean, na.rm = T),          type='l',          lwd=3,          lty=1,          col=\"red\") matplot(t(Y_miss),         type='l',          ylab='Y(t)',          xlab='time',          main='Plot of response curves with missingness',          col=rgb(0,0,0,alpha=0.6)) matlines(apply(t(Y_miss), 1, mean, na.rm = T),          type='l',          lwd=3,          lty=1,          col = \"red\")"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"mfpca","dir":"Articles","previous_headings":"","what":"MFPCA","title":"FunOnFun","text":"","code":"df = X_miss %>% FunOnFun::tibbleFormat(t) %>% FunOnFun::fpcaFormat(id_col = \"id\") df_Y = Y_miss %>% FunOnFun::tibbleFormat(t) %>% FunOnFun::fpcaFormat(id_col = \"id\")"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"get-univariate-fpca-results","dir":"Articles","previous_headings":"MFPCA","what":"Get Univariate FPCA Results","title":"FunOnFun","text":"","code":"res_X1 = fdapace::FPCA(df$Variable1,                        df$Time,                        list(dataType = \"Sparse\",                             error = F,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t)))  res_X2 = fdapace::FPCA(df$Variable2,                        df$Time,                        list(dataType = \"Sparse\",                             error = F,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t)))  res_Y1 = fdapace::FPCA(df_Y$Variable1,                        df_Y$Time,                        list(dataType = \"Sparse\",                             error = T,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t),                             methodSelectK = 2)) res_Y2 = fdapace::FPCA(df_Y$Variable2,                        df_Y$Time,                        list(dataType = \"Sparse\",                             error = T,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t),                             methodSelectK = 2))"},{"path":"https://bpark67.github.io/FunOnFun/articles/FunOnFun.html","id":"run-irregular-mfpca","dir":"Articles","previous_headings":"MFPCA","what":"Run Irregular MFPCA","title":"FunOnFun","text":"","code":"res = FunOnFun::irregMFPCA(components = 2,                            split = T,                            res_X1,                            res_X2)  res_Y = FunOnFun::irregMFPCA(components = 2,                              split = T,                              res_Y1,                              res_Y2)"},{"path":[]},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"covariates","dir":"Articles","previous_headings":"Simulate Data","what":"Covariates","title":"Simulation Study","text":"","code":"t = seq(0, 1, length.out = 100)  n = 500  components = 3  mean_funs = list(   function(t) -2*(t-0.5)^2 + 5,   function(t) 3*(t-0.75)^3 - 5   )  eigen_funs_list = list(   list(     function(t) sin(2*pi*t),     function(t) sin(4*pi*t),     function(t) sin(6*pi*t)   ),   list(     function(t) cos(3*pi*t),     function(t) cos(pi*t),     function(t) cos(5*pi*t)   ) )  lambdas = c(5, 3, 1)  X = FunOnFun::simMFPCA(16, t, n, 3, mean_funs, eigen_funs_list, lambdas, response = FALSE)"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"response","dir":"Articles","previous_headings":"Simulate Data","what":"Response","title":"Simulation Study","text":"","code":"mean_funs = list(   function(t) 6*exp(-(t-1)^2),   function(t) -2*14^(t-0.5) )  eigen_funs_list = list(   list(     function(t) cos(9*pi*t),     function(t) cos(5*pi*t),     function(t) cos(2*pi*t)   ),   list(     function(t) sin(3*pi*t),     function(t) sin(5*pi*t),     function(t) sin(7*pi*t)   ) )  B = matrix(c(-1, 0.5, 0.1, -0.5, 1, 0.1, 0.5, 0.5, -0.05),            nrow = components,            ncol = components)  # B = matrix(c(2, 1, 2, -1, -4, 1, 1, 3, 1), #            nrow = components, #            ncol = components)  # B = diag(c(3, 3, 3))  Y = FunOnFun::simMFPCA(16, t, n, 3, mean_funs, eigen_funs_list, lambdas, response = TRUE, B = B)  set.seed(0) sigma = 0.001 E = matrix(rnorm(2*length(t)*n, mean = 0, sd = sigma), n, 2*length(t))  Y$X = Y$X + E"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"orthogonalize-response","dir":"Articles","previous_headings":"Simulate Data","what":"Orthogonalize Response","title":"Simulation Study","text":"","code":"# cov_Y = Y$phi %*% t(B) %*% t(Y$D) %*% Y$D %*% B %*% t(Y$phi) + diag(rep(sigma^2, 2*length(t)))  popEig = FunOnFun::populationEigen(Y, B, t, sigma)  par(mfrow=c(1, 2)) image(popEig$pop_covY) image(cov(Y$X))"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"population-eigenfunctions-orthogonalized","dir":"Articles","previous_headings":"Simulate Data","what":"Population Eigenfunctions (Orthogonalized)","title":"Simulation Study","text":"","code":"# TODO: Make this into a function too; get phi_Y_df, Y_xi_pop, and B_PC_PC # TODO: Create a FunOnFun regression function that returns B; # TODO: Make simMFPCA return a class  # phi_Y_df = (eigen(cov_Y)$vectors[, 1:3]*sqrt(2*length(t))) %>% as.data.frame() popEig$pop_phiY  # Y_xi_pop = Y$X %*% (eigen(cov_Y)$vectors[, 1:3])/sqrt(2*length(t)) popEig$pop_xiY  # B_PC_PC = B %*% t(Y$phi) %*% (eigen(cov_Y)$vectors[, 1:3])/sqrt(2*length(t)) popEig$pop_B  # t(B_PC_PC) %*% Y$D %*% Y$D %*% B_PC_PC  t(popEig$pop_B) %*% Y$D %*% Y$D %*% popEig$pop_B"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"plot-simulated-data","dir":"Articles","previous_headings":"","what":"Plot Simulated Data","title":"Simulation Study","text":"","code":"matplot(t(X$X),          type='l',          ylab='X(t)',          xlab='time',          main='Plot of predictor curves',          col=rgb(0,0,0,alpha=0.4)) matlines(apply(t(X$X), 1, mean),          type='l',          lwd=3,          lty=1,          col=\"red\") matplot(t(Y$X),          type='l',          ylab='Y(t)',          xlab='time',          main='Plot of response curves',          col=rgb(0,0,0,alpha=0.6)) matlines(apply(t(Y$X), 1, mean),          type='l',          lwd=3,          lty=1,          col = \"red\")"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"simulate-missingness","dir":"Articles","previous_headings":"","what":"Simulate Missingness","title":"Simulation Study","text":"","code":"X_miss = FunOnFun::simMiss(99, X$X, t, seed = 51) Y_miss = FunOnFun::simMiss(99, Y$X, t, seed = 51)"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"fpca","dir":"Articles","previous_headings":"","what":"FPCA","title":"Simulation Study","text":"","code":"df = X_miss %>% FunOnFun::tibbleFormat(t) %>% FunOnFun::fpcaFormat(id_col = \"id\") df_Y = Y_miss %>% FunOnFun::tibbleFormat(t) %>% FunOnFun::fpcaFormat(id_col = \"id\") res_X1 = fdapace::FPCA(df$Variable1,                        df$Time,                        list(dataType = \"Sparse\",                             error = F,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t)))  res_X2 = fdapace::FPCA(df$Variable2,                        df$Time,                        list(dataType = \"Sparse\",                             error = F,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t)))  res_Y1 = fdapace::FPCA(df_Y$Variable1,                        df_Y$Time,                        list(dataType = \"Sparse\",                             error = T,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t),                             methodSelectK = 3)) res_Y2 = fdapace::FPCA(df_Y$Variable2,                        df_Y$Time,                        list(dataType = \"Sparse\",                             error = T,                             kernel = \"epan\",                             verbose = F,                             nRegGrid = length(t),                             methodSelectK = 3))"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"visualize-fpca","dir":"Articles","previous_headings":"","what":"Visualize FPCA","title":"Simulation Study","text":"","code":"act = data.frame(act1 = Y$mu[1:100],                  act2 = Y$mu[101:200]) hat = data.frame(hat1 = res_Y1$mu,                  hat2 = res_Y2$mu)  hat %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = hat1)) +   geom_line(data = act, aes(x = seq(0, 1, length.out = 100), y = act1), linetype = \"dashed\") +   theme_bw() hat %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = hat2)) +   geom_line(data = act, aes(x = seq(0, 1, length.out = 100), y = act2), linetype = \"dashed\") +   theme_bw() #phi_X2_df = Y$phi[101:200,] %>% as.data.frame() phi_Y1_df = (eigen(popEig$pop_covY[1:100,1:100])$vectors[, 1:3]*sqrt(100)) %>% as.data.frame()  res_Y1$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = V1), col = \"red\") +   geom_line(data = phi_Y1_df, aes(x = t, y = V1), col = \"red\", linetype = \"dashed\") +   theme_bw() res_Y1$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = V2), col = \"red\") +   geom_line(data = phi_Y1_df, aes(x = t, y = V2), col = \"red\", linetype = \"dashed\") +   theme_bw() res_Y1$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = -V3), col = \"red\") +   geom_line(data = phi_Y1_df, aes(x = t, y = V3), col = \"red\", linetype = \"dashed\") +   theme_bw() phi_Y2_df = (eigen(popEig$pop_covY[101:200,101:200])$vectors[, 1:3]*sqrt(length(t))) %>% as.data.frame()  res_Y2$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = V1), col = \"red\") +   geom_line(data = phi_Y2_df, aes(x = t, y = V1), col = \"red\", linetype = \"dashed\") +   theme_bw() res_Y2$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = V2), col = \"red\") +   geom_line(data = phi_Y2_df, aes(x = t, y = V2), col = \"red\", linetype = \"dashed\") +   theme_bw() res_Y2$phi[, 1:3] %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = t, y = V3), col = \"red\") +   geom_line(data = phi_Y2_df, aes(x = t, y = V3), col = \"red\", linetype = \"dashed\") +   theme_bw()"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"irregular-mfpca","dir":"Articles","previous_headings":"","what":"Irregular MFPCA","title":"Simulation Study","text":"","code":"res = FunOnFun::irregMFPCA(components = 3,                            split = T,                            res_X1,                            res_X2)  res_Y = FunOnFun::irregMFPCA(components = 3,                              split = T,                              res_Y1,                              res_Y2)"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"check-results","dir":"Articles","previous_headings":"Irregular MFPCA","what":"Check results","title":"Simulation Study","text":"","code":"eigenf = res$unstacked_phi colnames(eigenf) = c(\"var_1_1\", \"var_1_2\", \"var_1_3\", \"var_2_1\", \"var_2_2\", \"var_2_3\") eigens = res$xi colnames(eigens) = c(\"comp_1\", \"comp_2\", \"comp_3\") eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = var_1_1), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[1:100, 1]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_1_2), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[1:100, 2]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_1_3), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[1:100, 3]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = var_2_1), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[101:200, 1]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_2_2), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[101:200, 2]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_2_3), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = X$phi[101:200, 3]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigens = data.frame(est1 = eigens[,1]/sqrt(res$Dhat[1,1]),                     est2 = eigens[,2]/sqrt(res$Dhat[2,2]),                     est3 = eigens[,3]/sqrt(res$Dhat[3,3]),                     act1 = X$xi[, 1],                     act2 = X$xi[, 2],                     act3 = X$xi[, 3])  eigens %>%   ggplot(aes(x = est1, y = act1)) +   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x' eigens %>%   ggplot(aes(x = -est2, y = act2)) +   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x' eigens %>%   ggplot(aes(x = -est3, y = act3)) +   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x' eigenf = res_Y$unstacked_phi colnames(eigenf) = c(\"var_1_1\", \"var_1_2\", \"var_1_3\", \"var_2_1\", \"var_2_2\", \"var_2_3\") eigens = res_Y$xi %>% sweep(2, sqrt(diag(res_Y$Dhat)), \"/\") colnames(eigens) = c(\"comp_1\", \"comp_2\", \"comp_3\") # act = qr.Q(qr(Y$xi %*% B)) * sqrt(n) # Y_xi_pop = Y$X %*% (eigen(cov_Y)$vectors[, 1:3])/sqrt(n) # Y_xi_pop = (Y$X - rep(1, n) %*% t(Y$mu)) %*% (eigen(cov_Y)$vectors[, 1:3]) %>% sweep(2, lambdas, \"/\")/sqrt(n)  #TODO: Figure out how to use normalized scores!! What are the population normalized scores?  # eigens = data.frame(est1 = eigens[,1], #                     est2 = eigens[,2], #                     est3 = eigens[,3], #                     act1 = -act[, 1], #                     act2 = act[, 2], #                     act3 = -act[, 3])  phi_Y_df = (eigen(popEig$pop_covY)$vectors[, 1:3]*sqrt(2*length(t))) %>% as.data.frame()  eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = var_1_1), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[1:100, 1]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_1_2), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[1:100, 2]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_1_3), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[1:100, 3]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = var_2_1), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[101:200, 1]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_2_2), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[101:200, 2]), col = \"black\", linetype = \"dotted\") +   theme_bw() eigenf %>%   as.data.frame() %>%   ggplot() +   geom_line(aes(x = seq(0, 1, length.out = 100), y = -var_2_3), col = \"red\") +   geom_line(aes(x = seq(0, 1, length.out = 100), y = phi_Y_df[101:200, 3]), col = \"black\", linetype = \"dotted\") +   theme_bw() # eigens %>% #   ggplot(aes(x = est1, y = act1)) + #   geom_point() + #   geom_abline(intercept = 0, slope = 1, col = \"red\") + #   geom_smooth(method = \"lm\", se = F) + #   theme_bw() #  # eigens %>% #   ggplot(aes(x = -est2, y = act2)) + #   geom_point() + #   geom_abline(intercept = 0, slope = 1, col = \"red\") + #   geom_smooth(method = \"lm\", se = F) + #   theme_bw() #  # eigens %>% #   ggplot(aes(x = -est3, y = act3)) + #   geom_point() + #   geom_abline(intercept = 0, slope = 1, col = \"red\") + #   geom_smooth(method = \"lm\", se = F) + #   theme_bw()  eigens %>%   ggplot(aes(x = res_Y$xi[,1], y = popEig$pop_xiY[,1])) +  # res_Y$xi[,1]   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x' eigens %>%   ggplot(aes(x = -res_Y$xi[,2], y = popEig$pop_xiY[,2])) +   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x' eigens %>%   ggplot(aes(x = res_Y$xi[,3], y = popEig$pop_xiY[,3])) +   geom_point() +   geom_abline(intercept = 0, slope = 1, col = \"red\") +   geom_smooth(method = \"lm\", se = F) +   theme_bw() #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"regression","dir":"Articles","previous_headings":"","what":"Regression","title":"Simulation Study","text":"","code":"# response = res_Y$xi # predictor = res$xi # X_xi_pop <- Y$xi%*%Y$D   # mod <- lm(response ~ 0 + predictor) Bhat = FunOnFun::funOnFun(res_Y, res)  # mod_sc_pop <- lm(popEig$pop_xiY ~ 0 + X_xi_pop) Bestimand = FunOnFun::populationReg(X, popEig$pop_xiY)     Bestimand; Bhat$Bhat; popEig$pop_B #>            [,1]        [,2]          [,3] #> xiX1  1.2084706 -0.22247723  0.0001157154 #> xiX2 -0.8022158 -0.93077996 -0.0001067740 #> xiX3 -0.1476355 -0.00865128  0.0287580183 #>               [,1]        [,2]          [,3] #> pred$xi1 1.1678595  0.21588536 -4.375704e-05 #> pred$xi2 0.7603738 -0.92345245 -6.280531e-05 #> pred$xi3 0.1516143 -0.02168497  6.384040e-03 #>            [,1]         [,2]          [,3] #> [1,]  1.2084720 -0.222477648  0.0001151556 #> [2,] -0.8022148 -0.930780571 -0.0001061576 #> [3,] -0.1476354 -0.008651756  0.0287567116"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"d-comparison","dir":"Articles","previous_headings":"Regression","what":"2D Comparison","title":"Simulation Study","text":"","code":"# population = (eigen(popEig$pop_covY)$vectors[, 1:3]*sqrt(2*length(t))) %*% popEig$pop_B %*%  t(X$phi) population = FunOnFun::populationBeta(popEig$pop_covY, popEig$pop_B, t, X)  # estimated = res_Y$stacked_phi %*% mod$coefficients %*%  t(res$stacked_phi) estimated = FunOnFun::reconBeta(res_Y, res, Bhat$Bhat)  fig1 <- plotly::plot_ly(z = population,                          type = \"heatmap\",                          zmin = min(population),                          zmax = max(population)) fig2 <- plotly::plot_ly(z = estimated,                          type = \"heatmap\",                          zmin = min(estimated),                         zmax = max(estimated))  plotly::subplot(fig1, fig2)"},{"path":"https://bpark67.github.io/FunOnFun/articles/Simulation-Study.html","id":"d-comparison-1","dir":"Articles","previous_headings":"Regression","what":"3D Comparison","title":"Simulation Study","text":"","code":"estimated = estimated - 15  population_colorscale <- list(   list(0, \"rgb(255, 0, 0)\"),   list(1, \"rgb(0, 255, 0)\") )  estimated_colorscale <- list(   list(0, \"rgb(255, 0, 0)\"),   list(1, \"rgb(0, 255, 0)\") )  fig = plotly::plot_ly(showscale = F) %>%    plotly::add_surface(z = ~population,                        cmin = min(population),                        cmax = max(population),                       colorscale = population_colorscale) %>%    plotly::add_surface(z = ~estimated,                        cmin = min(estimated),                       cmax = max(estimated),                       colorscale = estimated_colorscale)  fig"},{"path":"https://bpark67.github.io/FunOnFun/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bumjun Park. Maintainer.","code":""},{"path":"https://bpark67.github.io/FunOnFun/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Park B (2024). FunOnFun: Conducts Function Function Regression Based Irregular MFPCA. R package version 0.1.0, https://bpark67.github.io/FunOnFun/.","code":"@Manual{,   title = {FunOnFun: Conducts Function on Function Regression Based on Irregular MFPCA},   author = {Bumjun Park},   year = {2024},   note = {R package version 0.1.0},   url = {https://bpark67.github.io/FunOnFun/}, }"},{"path":[]},{"path":"https://bpark67.github.io/FunOnFun/index.html","id":"purpose","dir":"","previous_headings":"","what":"Purpose","title":"Conducts Function on Function Regression Based on Irregular MFPCA","text":"package multivariate functional Principal Component Analysis (MFPCA) conducts function function regression MFPCA scores. URL GitHub URL Website","code":""},{"path":"https://bpark67.github.io/FunOnFun/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Conducts Function on Function Regression Based on Irregular MFPCA","text":"can install development version FunOnFun GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"bpark67/FunOnFun\")"},{"path":"https://bpark67.github.io/FunOnFun/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Conducts Function on Function Regression Based on Irregular MFPCA","text":"package depends magrittr, dplyr, purrr, tsibble, tibble, brolgar.","code":""},{"path":"https://bpark67.github.io/FunOnFun/index.html","id":"session-info","dir":"","previous_headings":"","what":"Session Info","title":"Conducts Function on Function Regression Based on Irregular MFPCA","text":"tool developed using following R session:","code":"devtools::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.3.3 (2024-02-29) #>  os       macOS Sonoma 14.4.1 #>  system   x86_64, darwin20 #>  ui       X11 #>  language (EN) #>  collate  en_US.UTF-8 #>  ctype    en_US.UTF-8 #>  tz       America/Los_Angeles #>  date     2024-05-23 #>  pandoc   3.1.11 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/x86_64/ (via rmarkdown) #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package     * version date (UTC) lib source #>  cachem        1.1.0   2024-05-16 [1] CRAN (R 4.3.3) #>  cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.0) #>  devtools      2.4.5   2022-10-11 [1] CRAN (R 4.3.0) #>  digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.2) #>  ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.3.0) #>  evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.0) #>  fastmap       1.2.0   2024-05-15 [1] CRAN (R 4.3.3) #>  fs            1.6.4   2024-04-25 [1] CRAN (R 4.3.2) #>  glue          1.7.0   2024-01-09 [1] CRAN (R 4.3.0) #>  htmltools     0.5.8.1 2024-04-04 [1] CRAN (R 4.3.2) #>  htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.0) #>  httpuv        1.6.15  2024-03-26 [1] CRAN (R 4.3.2) #>  knitr         1.45    2023-10-30 [1] CRAN (R 4.3.0) #>  later         1.3.2   2023-12-06 [1] CRAN (R 4.3.0) #>  lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.3.0) #>  magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.3.0) #>  memoise       2.0.1   2021-11-26 [1] CRAN (R 4.3.0) #>  mime          0.12    2021-09-28 [1] CRAN (R 4.3.0) #>  miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.3.0) #>  pkgbuild      1.4.4   2024-03-17 [1] CRAN (R 4.3.2) #>  pkgload       1.3.4   2024-01-16 [1] CRAN (R 4.3.0) #>  profvis       0.3.8   2023-05-02 [1] CRAN (R 4.3.0) #>  promises      1.3.0   2024-04-05 [1] CRAN (R 4.3.2) #>  purrr         1.0.2   2023-08-10 [1] CRAN (R 4.3.0) #>  R6            2.5.1   2021-08-19 [1] CRAN (R 4.3.0) #>  Rcpp          1.0.12  2024-01-09 [1] CRAN (R 4.3.0) #>  remotes       2.5.0   2024-03-17 [1] CRAN (R 4.3.2) #>  rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.0) #>  rmarkdown     2.27    2024-05-17 [1] CRAN (R 4.3.3) #>  rstudioapi    0.16.0  2024-03-24 [1] CRAN (R 4.3.2) #>  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.0) #>  shiny         1.8.1.1 2024-04-02 [1] CRAN (R 4.3.2) #>  stringi       1.8.4   2024-05-06 [1] CRAN (R 4.3.2) #>  stringr       1.5.1   2023-11-14 [1] CRAN (R 4.3.0) #>  urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.3.0) #>  usethis       2.2.3   2024-02-19 [1] CRAN (R 4.3.2) #>  vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.3.0) #>  xfun          0.44    2024-05-15 [1] CRAN (R 4.3.3) #>  xtable        1.8-4   2019-04-21 [1] CRAN (R 4.3.0) #>  yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.0) #>  #>  [1] /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_mu.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to generate mean functions for each variable — .generate_mu","title":"A function to generate mean functions for each variable — .generate_mu","text":"function generate mean functions variable","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_mu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to generate mean functions for each variable — .generate_mu","text":"","code":".generate_mu(t, func_list)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_mu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to generate mean functions for each variable — .generate_mu","text":"t vector time points func_list list functions generate mean functions","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_mu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to generate mean functions for each variable — .generate_mu","text":"t num.var matrix mean functions","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_phi.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to generate orthogonal eigenfunctions — .generate_phi","title":"A function to generate orthogonal eigenfunctions — .generate_phi","text":"function generate orthogonal eigenfunctions","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_phi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to generate orthogonal eigenfunctions — .generate_phi","text":"","code":".generate_phi(t, eigen_funs)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_phi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to generate orthogonal eigenfunctions — .generate_phi","text":"t vector time points eigen_funs list functions generate eigenfunctions; Length match number components","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_phi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to generate orthogonal eigenfunctions — .generate_phi","text":"t number components matrix eigenfunctions inner product length t * \\(I_n\\)","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_xi.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to generate orthonormal eigenscores — .generate_xi","title":"A function to generate orthonormal eigenscores — .generate_xi","text":"function generate orthonormal eigenscores","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_xi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to generate orthonormal eigenscores — .generate_xi","text":"","code":".generate_xi(n, components)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_xi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to generate orthonormal eigenscores — .generate_xi","text":"n Number subjects components Number components","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-generate_xi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to generate orthonormal eigenscores — .generate_xi","text":"n length(t) matrix orthogonal eigenscores inner product \\(n \\times I_n\\)","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-longFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to convert a data frame into a long format — .longFormat","title":"A function to convert a data frame into a long format — .longFormat","text":"function convert data frame long format","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-longFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to convert a data frame into a long format — .longFormat","text":"","code":".longFormat(dat)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-longFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to convert a data frame into a long format — .longFormat","text":"dat data frame data","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-longFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to convert a data frame into a long format — .longFormat","text":"data frame long format","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-normalizer.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to normalize a matrix — .normalizer","title":"A function to normalize a matrix — .normalizer","text":"function normalize matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-normalizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to normalize a matrix — .normalizer","text":"","code":".normalizer(mat, normal = NULL)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-normalizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to normalize a matrix — .normalizer","text":"mat matrix normal scalar normalize matrix. Default number rows matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-normalizer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to normalize a matrix — .normalizer","text":"matrix normalized inner product \\(normal*I_n\\)","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-stack_phi.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to stack multiple eigenfunctions if there are multiple variables — .stack_phi","title":"A function to stack multiple eigenfunctions if there are multiple variables — .stack_phi","text":"function stack multiple eigenfunctions multiple variables","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-stack_phi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to stack multiple eigenfunctions if there are multiple variables — .stack_phi","text":"","code":".stack_phi(t, eigen_funs_list)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-stack_phi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to stack multiple eigenfunctions if there are multiple variables — .stack_phi","text":"t vector time points eigen_funs_list list lists functions generate eigenfunctions variable","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-stack_phi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to stack multiple eigenfunctions if there are multiple variables — .stack_phi","text":"stacked matrix eigenfunctions","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-vector_filler.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to fill an empty vector with values from a data frame — .vector_filler","title":"A function to fill an empty vector with values from a data frame — .vector_filler","text":"function fill empty vector values data frame","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-vector_filler.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to fill an empty vector with values from a data frame — .vector_filler","text":"","code":".vector_filler(v, target, source, id_col, uid)"},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-vector_filler.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to fill an empty vector with values from a data frame — .vector_filler","text":"v vector fill target target column fill source source data frame id_col column contains unique identifier subject uid unique identifier subject","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/dot-vector_filler.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to fill an empty vector with values from a data frame — .vector_filler","text":"filled vector","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/fpcaFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to format data for FPCA — fpcaFormat","title":"A function to format data for FPCA — fpcaFormat","text":"function format data FPCA","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/fpcaFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to format data for FPCA — fpcaFormat","text":"","code":"fpcaFormat(dat, id_col, var_cols = NULL)"},{"path":"https://bpark67.github.io/FunOnFun/reference/fpcaFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to format data for FPCA — fpcaFormat","text":"dat data frame data id_col Designates column contains unique identifier subject var_cols vector column names contain variables interest","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/fpcaFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to format data for FPCA — fpcaFormat","text":"tibble data FPCA format","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/funOnFun.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to conduct Function on Function regression based on eigenscores — funOnFun","title":"Function to conduct Function on Function regression based on eigenscores — funOnFun","text":"Function conduct Function Function regression based eigenscores","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/funOnFun.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to conduct Function on Function regression based on eigenscores — funOnFun","text":"","code":"funOnFun(resp, pred)"},{"path":"https://bpark67.github.io/FunOnFun/reference/funOnFun.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to conduct Function on Function regression based on eigenscores — funOnFun","text":"resp response `irregMFPCA` object pred predictor `irregMFPCA` object","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/funOnFun.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to conduct Function on Function regression based on eigenscores — funOnFun","text":"regression matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/irregMFPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to perform irregular MFPCA — irregMFPCA","title":"A function to perform irregular MFPCA — irregMFPCA","text":"function perform irregular MFPCA","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/irregMFPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to perform irregular MFPCA — irregMFPCA","text":"","code":"irregMFPCA(components = NULL, split = F, ...)"},{"path":"https://bpark67.github.io/FunOnFun/reference/irregMFPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to perform irregular MFPCA — irregMFPCA","text":"components Number principal components consider split Whether split data separate variables ... list FPCA objects","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/irregMFPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to perform irregular MFPCA — irregMFPCA","text":"list containing unstacked (wide) eigenfunctions, stacked (long) eigenfunctions, eigenscores, Dhat, Xhat","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/mip.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Inner Product (Covariance) of Matrices — mip","title":"Compute Inner Product (Covariance) of Matrices — mip","text":"Compute Inner Product (Covariance) Matrices","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/mip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Inner Product (Covariance) of Matrices — mip","text":"","code":"mip(mat)"},{"path":"https://bpark67.github.io/FunOnFun/reference/mip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Inner Product (Covariance) of Matrices — mip","text":"mat n x p matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/mip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Inner Product (Covariance) of Matrices — mip","text":"p x p matrix inner product columns mat","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://bpark67.github.io/FunOnFun/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to reconstruct the estimand, the population beta matrix, from the predictor `simMFPCA` object — populationBeta","title":"A function to reconstruct the estimand, the population beta matrix, from the predictor `simMFPCA` object — populationBeta","text":"function reconstruct estimand, population beta matrix, predictor `simMFPCA` object","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to reconstruct the estimand, the population beta matrix, from the predictor `simMFPCA` object — populationBeta","text":"","code":"populationBeta(popCovY, popB, t, X)"},{"path":"https://bpark67.github.io/FunOnFun/reference/populationBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to reconstruct the estimand, the population beta matrix, from the predictor `simMFPCA` object — populationBeta","text":"popCovY population covariance matrix response popB population B matrix t time points X predictor `simMFPCA` object","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationBeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to reconstruct the estimand, the population beta matrix, from the predictor `simMFPCA` object — populationBeta","text":"reconstructed population beta matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationEigen.html","id":null,"dir":"Reference","previous_headings":"","what":"Return Orthogonalized Population Quantities for Non-orthogonal Data Rotated by a matrix B — populationEigen","title":"Return Orthogonalized Population Quantities for Non-orthogonal Data Rotated by a matrix B — populationEigen","text":"Return Orthogonalized Population Quantities Non-orthogonal Data Rotated matrix B","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationEigen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return Orthogonalized Population Quantities for Non-orthogonal Data Rotated by a matrix B — populationEigen","text":"","code":"populationEigen(Y, B, t, sigma)"},{"path":"https://bpark67.github.io/FunOnFun/reference/populationEigen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return Orthogonalized Population Quantities for Non-orthogonal Data Rotated by a matrix B — populationEigen","text":"Y simMFPCA object B matrix rotate data t vector time points sigma scalar noise","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationEigen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return Orthogonalized Population Quantities for Non-orthogonal Data Rotated by a matrix B — populationEigen","text":"list (orthogonalized) population covariance, eigenfunctions, eigenscores, B","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationReg.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to return estimand of `funOnFun` — populationReg","title":"Function to return estimand of `funOnFun` — populationReg","text":"Function return estimand `funOnFun`","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationReg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to return estimand of `funOnFun` — populationReg","text":"","code":"populationReg(X, popXiY)"},{"path":"https://bpark67.github.io/FunOnFun/reference/populationReg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to return estimand of `funOnFun` — populationReg","text":"X predictor `simMFPCA` object popXiY population orthogonalized eigenscores response","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/populationReg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to return estimand of `funOnFun` — populationReg","text":"estimand regression matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/reconBeta.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to reconstruct the beta matrix from the response and predictor `irregMFPCA` objects — reconBeta","title":"A function to reconstruct the beta matrix from the response and predictor `irregMFPCA` objects — reconBeta","text":"function reconstruct beta matrix response predictor `irregMFPCA` objects","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/reconBeta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to reconstruct the beta matrix from the response and predictor `irregMFPCA` objects — reconBeta","text":"","code":"reconBeta(resp, pred, Bhat)"},{"path":"https://bpark67.github.io/FunOnFun/reference/reconBeta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to reconstruct the beta matrix from the response and predictor `irregMFPCA` objects — reconBeta","text":"resp response `irregMFPCA` object pred predictor `irregMFPCA` object Bhat estimated B matrix `funOnFun` function","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/reconBeta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to reconstruct the beta matrix from the response and predictor `irregMFPCA` objects — reconBeta","text":"reconstructed estimated beta matrix","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/regularizeTime.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to regularize time for each id in a dataset — regularizeTime","title":"A function to regularize time for each id in a dataset — regularizeTime","text":"function regularize time id dataset","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/regularizeTime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to regularize time for each id in a dataset — regularizeTime","text":"","code":"regularizeTime(dat, id_col)"},{"path":"https://bpark67.github.io/FunOnFun/reference/regularizeTime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to regularize time for each id in a dataset — regularizeTime","text":"dat data frame clustered data id_col name column id","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/regularizeTime.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to regularize time for each id in a dataset — regularizeTime","text":"data frame new column t goes 0 1 id","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMFPCA.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to generate randomly simulated data for multivariate functional principal component analysis — simMFPCA","title":"A function to generate randomly simulated data for multivariate functional principal component analysis — simMFPCA","text":"function generate randomly simulated data multivariate functional principal component analysis","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMFPCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to generate randomly simulated data for multivariate functional principal component analysis — simMFPCA","text":"","code":"simMFPCA(   seed,   t,   n,   components,   mean_funs,   eigen_funs_list,   lambdas,   response = FALSE,   B = NULL )"},{"path":"https://bpark67.github.io/FunOnFun/reference/simMFPCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to generate randomly simulated data for multivariate functional principal component analysis — simMFPCA","text":"seed seed random number generation t vector time points n Number subjects components Number principal components mean_funs list functions generate mean functions variable eigen_funs_list list lists functions generate eigenfunctions variable lambdas vector magnitudes eigenvalues response logical indicating whether data response covariate B matrix regression coefficients response data","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMFPCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to generate randomly simulated data for multivariate functional principal component analysis — simMFPCA","text":"list simulated data","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMiss.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to simulate missing data — simMiss","title":"A function to simulate missing data — simMiss","text":"function simulate missing data","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMiss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to simulate missing data — simMiss","text":"","code":"simMiss(n_obs, dat, t = seq(0, 1, length.out = 51), seed = 51)"},{"path":"https://bpark67.github.io/FunOnFun/reference/simMiss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to simulate missing data — simMiss","text":"n_obs Number observations keep dat matrix data t vector time points seed seed random number generation","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/simMiss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to simulate missing data — simMiss","text":"matrix data missing values","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/tibbleFormat.html","id":null,"dir":"Reference","previous_headings":"","what":"A function to convert a matrix into a tibble — tibbleFormat","title":"A function to convert a matrix into a tibble — tibbleFormat","text":"function convert matrix tibble","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/tibbleFormat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A function to convert a matrix into a tibble — tibbleFormat","text":"","code":"tibbleFormat(dat, t)"},{"path":"https://bpark67.github.io/FunOnFun/reference/tibbleFormat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A function to convert a matrix into a tibble — tibbleFormat","text":"dat matrix data t vector time points","code":""},{"path":"https://bpark67.github.io/FunOnFun/reference/tibbleFormat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A function to convert a matrix into a tibble — tibbleFormat","text":"tibble data","code":""}]
